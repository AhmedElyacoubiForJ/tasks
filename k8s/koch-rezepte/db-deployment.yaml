# ğŸ§‘â€ğŸ³ Schritt-fÃ¼r-Schritt: Postgres-Rezept starten
# 1ï¸âƒ£ Namespace anlegen
# kubectl create namespace dev
#
# 2ï¸âƒ£ ConfigMap mit dem Init-Skript bereitstellen
# kubectl apply -f ./k8s/koch-rezepte/init-db-script.yaml
#
# 3ï¸âƒ£ Postgres-Deployment starten
# kubectl apply -f ./k8s/koch-rezepte/db-deployment.yaml
#
# Und dann prÃ¼fen, ob unser dev_user schon mit dem KochlÃ¶ffel wedelt ğŸ˜„
# ğŸ” Danach prÃ¼fen wir:
# ğŸ§‘â€ğŸ³ NÃ¤chste Schritte am Herd
# Pod-Status prÃ¼fen
# kubectl get pods -n dev
#
# Logs anschauen (Init-Skript-Ausgabe)
# kubectl logs <pod-name> -n dev
#
# In den Container springen
# kubectl exec -it <pod-name> -n dev -- sh
#
# Mit psql verbinden
# psql -U admin -d tasks_dev_db
# ğŸ§‘â€ğŸ³ Was tun, wenn du frisch starten willst?
#
# ğŸ§¼ 1. Deployment lÃ¶schen
# kubectl delete deployment postgres-dev -n dev
#
# ğŸ§¼ 2. ConfigMap optional lÃ¶schen (wenn du sie Ã¤ndern willst)
# kubectl delete configmap init-db-script -n dev
#
# ğŸ§¼ 3. Volume leeren (wichtig!)
# kubectl delete pod <pod-name> -n dev
# â†’ Dadurch wird der Pod samt Volume-Inhalt entfernt
# â†’ Beim nÃ¤chsten Deployment-Start wird das Init-Skript neu ausgefÃ¼hrt
# ğŸ” Pod-Namen herausfinden
# kubectl get pods -n dev
# â†’ Oder du verwendest emptyDir wie bisher, dann reicht das LÃ¶schen des Pods/Deployments
#
# âœ… LÃ¶sung: Wenn du wirklich aufrÃ¤umen willst
# kubectl delete deployment tasks-app -n dev
# â†’ Danach verschwinden die Pods dauerhaft, bis du das Deployment neu erstellst
#
# ğŸ” Bonus: Deployment-Status prÃ¼fen
# kubectl get deployments -n dev
# ğŸ” Dann neu anwenden:
# kubectl apply -f ./k8s/koch-rezepte/init-db-script.yaml
# kubectl apply -f ./k8s/koch-rezepte/db-deployment.yaml
# db-deployment.yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres-dev
  namespace: dev
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgres-dev
  template:
    metadata:
      labels:
        app: postgres-dev
    spec:
      containers:
        - name: postgres
          image: postgres:15-alpine
          ports:
            - containerPort: 5432

          # ğŸ§‘â€ğŸ³ Diese Umgebungsvariablen werden sowohl vom Container als auch vom Init-Skript verwendet.
          # Sie definieren die Superuser-Zugangsdaten und den dedizierten App-User.
          env:
            - name: POSTGRES_DB
              value: tasks_dev_db
            - name: POSTGRES_USER
              value: admin
            - name: POSTGRES_PASSWORD
              value: adminpass
            - name: APP_DB_USER
              value: dev_user
            - name: APP_DB_PASSWORD
              value: dev_secret

          volumeMounts:
            # ğŸ§‘â€ğŸ³ Persistente Datenbankdaten werden hier gespeichert.
            - name: pgdata
              mountPath: /var/lib/postgresql/data

            # ğŸ§‘â€ğŸ³ Das Init-Skript wird beim ersten Start automatisch ausgefÃ¼hrt,
            # wenn das Volume leer ist. Es wird als einzelne Datei aus der ConfigMap gemountet.
            - name: init-script
              mountPath: /docker-entrypoint-initdb.d/init-dev-db.sh
              subPath: init-dev-db.sh

          # ğŸ§‘â€ğŸ³ readinessProbe prÃ¼ft regelmÃ¤ÃŸig, ob Postgres bereit ist.
          # So weiÃŸ Minikube, wann der Container einsatzfÃ¤hig ist.
          readinessProbe:
            exec:
              command: ["pg_isready", "-U", "admin", "-d", "tasks_dev_db"]
            initialDelaySeconds: 10
            periodSeconds: 10

      volumes:
        - name: pgdata
          emptyDir: {}

        # ğŸ§‘â€ğŸ³ Die ConfigMap enthÃ¤lt das Init-Skript.
        # Sie wird hier eingebunden und Ã¼ber subPath als einzelne Datei gemountet.
        - name: init-script
          configMap:
            name: init-db-script
